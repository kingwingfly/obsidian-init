/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TableEnhancer2
});
module.exports = __toCommonJS(main_exports);
var import_obsidian4 = require("obsidian");

// src/global.ts
var editingCellClassName = "editing-cell";
var hoveredCellClassName = "hovered-cell";
function getCaretPosition(editableElem) {
  let caretPos = 0, sel, range;
  sel = activeWindow.getSelection();
  if (sel && sel.rangeCount) {
    range = sel.getRangeAt(0);
    if (range.commonAncestorContainer.parentNode == editableElem) {
      caretPos = range.endOffset;
    }
  }
  return caretPos;
}
function setCaretPosition(editableElem, newPos) {
  let caretPos = 0, sel, range = activeDocument.createRange();
  sel = activeWindow.getSelection();
  if (sel && sel.rangeCount) {
    range.setStart(editableElem.childNodes[0], newPos);
    range.collapse(true);
    sel.removeAllRanges();
    sel.addRange(range);
  }
  return caretPos;
}
function getCell(table, i, j) {
  let result = null;
  try {
    result = table.cells[i][j];
  } catch (err) {
    result = null;
    console.log("Cannot get cell i=", i, ", j=", j, " from table=", table);
  }
  return result;
}
function parseCellId(cellId) {
  const arr = cellId.split("_");
  return {
    tableLine: parseInt(arr[1]),
    i: parseInt(arr[2]),
    j: parseInt(arr[3])
  };
}

// src/tableEditor.ts
var import_obsidian = require("obsidian");

// src/editorUtils.ts
var getLineStartPos = (line) => ({
  line,
  ch: 0
});
var getLineEndPos = (line, editor) => ({
  line,
  ch: editor.getLine(line).length
});
var deleteLines = (editor, from, to) => {
  if (to === editor.lastLine() + 1) {
    return replaceRangeWithoutScroll(editor, "", getLineEndPos(from - 1, editor), getLineEndPos(to, editor));
  } else {
    return replaceRangeWithoutScroll(editor, "", getLineStartPos(from), getLineStartPos(to));
  }
};
var deleteLine = (editor, line) => {
  return deleteLines(editor, line, line + 1);
};
var getLeadingWhitespace = (lineContent) => {
  const indentation = lineContent.match(/^\s+/);
  return indentation ? indentation[0] : "";
};
var insertLineBelow = (editor, line) => {
  const endOfCurrentLine = getLineEndPos(line, editor);
  const indentation = getLeadingWhitespace(editor.getLine(line));
  return replaceRangeWithoutScroll(editor, "\n" + indentation, endOfCurrentLine);
};
var zf = (e, t) => {
  if (t.line < 0)
    return 0;
  const n = t.line + 1;
  if (n > e.lines)
    return e.length;
  const i = e.line(n);
  return isFinite(t.ch) ? t.ch < 0 ? i.from + Math.max(0, i.length + t.ch) : i.from + t.ch : i.to;
};
var replaceRangeWithoutScroll = (editor, replacement, from, to) => {
  const cm = editor.cm;
  const state = cm.state.doc;
  const from2 = zf(state, from);
  const to2 = to ? zf(state, to) : from2;
  return {
    changes: {
      from: from2,
      to: to2,
      insert: replacement
    },
    scrollIntoView: false,
    sequential: false
  };
};
var setLineWithoutScroll = (editor, n, text) => {
  const cm = editor.cm;
  const state = cm.state.doc;
  const from = zf(state, { line: n, ch: 0 });
  const to = zf(state, { line: n, ch: editor.getLine(n).length });
  return {
    changes: {
      from,
      to,
      insert: text
    },
    scrollIntoView: false,
    sequential: false
  };
};
function withoutScrollAndFocus(editorView, callback) {
  const scrollDom = editorView.scrollDOM;
  const x = scrollDom.scrollLeft;
  const y = scrollDom.scrollTop;
  const resetScroll = () => {
    scrollDom.scrollTo(x, y);
  };
  scrollDom.addEventListener("scroll", resetScroll, true);
  editorView.contentDOM.blur();
  callback();
  editorView.contentDOM.blur();
  scrollDom.removeEventListener("scroll", resetScroll, true);
}

// src/tableEditor.ts
var TableEditor = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  getTable(tableLine) {
    const markdownView = this.plugin.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (markdownView instanceof import_obsidian.MarkdownView && markdownView.editor) {
      const editor = markdownView.editor;
      const lineCount = editor.lineCount();
      const cells = [];
      let match;
      let notStandard = false;
      let formatLine = editor.getLine(tableLine + 1);
      const formatRowRegex = /^\s*(\|)?(?:\s*:?\s*?-+\s*:?\s*\|?){2,}/;
      match = formatRowRegex.exec(formatLine);
      if (!match) {
        for (let i2 = 1; ; i2++) {
          const down = tableLine + 1 + i2;
          const up = tableLine + 1 - i2;
          if (up >= lineCount && down < 0)
            break;
          if (down >= 0) {
            match = formatRowRegex.exec(editor.getLine(down));
            if (match) {
              tableLine = down - 1;
              break;
            }
          }
          if (up < lineCount) {
            match = formatRowRegex.exec(editor.getLine(up));
            if (match) {
              tableLine = down - 1;
              break;
            }
          }
        }
        if (!match)
          return null;
      }
      formatLine = editor.getLine(tableLine + 1);
      if (!match[1]) {
        formatLine = `| ${formatLine} |`;
        editor.setLine(tableLine + 1, formatLine);
        notStandard = true;
      }
      const parsedFormatLine = formatLine.split("|").slice(1, -1);
      let headerLine = editor.getLine(tableLine);
      if (notStandard) {
        headerLine = `| ${headerLine} |`;
        editor.setLine(tableLine, headerLine);
      }
      const parsedHeaderLine = headerLine.split("|").slice(1, -1);
      cells.push(parsedHeaderLine);
      let i = tableLine + 1;
      const notStandardRegex = /^\s*[^|]*\|/;
      while (++i < lineCount) {
        let bodyLine = editor.getLine(i);
        if (notStandard) {
          if (notStandardRegex.exec(bodyLine)) {
            bodyLine = `| ${bodyLine} |`;
            editor.setLine(i, bodyLine);
            const parsedBodyLine = bodyLine.split("|").slice(1, -1);
            cells.push(parsedBodyLine);
          } else
            break;
        } else {
          if (bodyLine.trimStart().startsWith("|")) {
            const parsedBodyLine = bodyLine.split("|").slice(1, -1);
            cells.push(parsedBodyLine);
          } else
            break;
        }
      }
      return {
        fromLine: tableLine,
        toLine: i,
        formatLine: parsedFormatLine,
        cells
      };
    }
    return null;
  }
  static getLineNumber(table, line) {
    return table.fromLine + (line == 0 ? 0 : line + 1);
  }
  async updateCell(table, i, j, newContent) {
    if (!table)
      return;
    const markdownView = this.plugin.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    const editor = markdownView == null ? void 0 : markdownView.editor;
    const editorView = editor == null ? void 0 : editor.cm;
    if (!editor || !editorView) {
      console.error("Cannot get editor");
      return;
    }
    if (newContent == table.cells[i][j])
      return;
    table.cells[i][j] = newContent;
    const rowLineNumber = TableEditor.getLineNumber(table, i);
    const newLine = TableEditor.rowCells2rowString(table.cells[i]);
    withoutScrollAndFocus(editorView, () => {
      editorView.dispatch(setLineWithoutScroll(editor, rowLineNumber, newLine));
    });
  }
  async insertColRight(table, colIndex, col) {
    if (!table)
      return;
    const markdownView = this.plugin.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    const editor = markdownView == null ? void 0 : markdownView.editor;
    const editorView = editor == null ? void 0 : editor.cm;
    if (!editor || !editorView) {
      console.error("Cannot get editor");
      return;
    }
    table.formatLine.splice(colIndex + 1, 0, "---");
    table.cells.forEach((row, idx) => {
      const newCell = col ? col[idx] : "   ";
      row.splice(colIndex + 1, 0, newCell);
    });
    const transactionSpecs = [];
    transactionSpecs.push(setLineWithoutScroll(editor, table.fromLine + 1, TableEditor.rowCells2rowString(table.formatLine)));
    for (let i = 0; i < table.cells.length; i++) {
      const lineNumber = TableEditor.getLineNumber(table, i);
      transactionSpecs.push(setLineWithoutScroll(editor, lineNumber, TableEditor.rowCells2rowString(table.cells[i])));
    }
    withoutScrollAndFocus(editorView, () => {
      editorView.dispatch(...transactionSpecs);
    });
  }
  async insertRowBelow(table, rowIndex, row) {
    if (!table)
      return;
    const markdownView = this.plugin.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    const editor = markdownView == null ? void 0 : markdownView.editor;
    const editorView = editor == null ? void 0 : editor.cm;
    if (!editor || !editorView) {
      console.error("Cannot get editor");
      return;
    }
    if (!row) {
      row = [];
      let i = table.formatLine.length;
      while (i--) {
        row.push("  ");
      }
    }
    const rowLineNumber = TableEditor.getLineNumber(table, rowIndex);
    withoutScrollAndFocus(editorView, () => {
      editorView.dispatch(insertLineBelow(editor, rowLineNumber));
      editorView.dispatch(setLineWithoutScroll(editor, rowLineNumber + 1, TableEditor.rowCells2rowString(row)));
    });
  }
  async setColAligned(table, colIndex, aligned) {
    if (!table)
      return;
    const markdownView = this.plugin.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    const editor = markdownView == null ? void 0 : markdownView.editor;
    const editorView = editor == null ? void 0 : editor.cm;
    if (!editor || !editorView) {
      console.error("Cannot get editor");
      return;
    }
    table.formatLine[colIndex] = aligned == "left" ? ":----" : aligned == "right" ? "----:" : ":---:";
    withoutScrollAndFocus(editorView, () => {
      editorView.dispatch(setLineWithoutScroll(editor, table.fromLine + 1, TableEditor.rowCells2rowString(table.formatLine)));
    });
  }
  async swapCols(table, colIndex1, colIndex2) {
    if (!table)
      return;
    const markdownView = this.plugin.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    const editor = markdownView == null ? void 0 : markdownView.editor;
    const editorView = editor == null ? void 0 : editor.cm;
    if (!editor || !editorView) {
      console.error("Cannot get editor");
      return;
    }
    const colNum = table.cells[0].length;
    if (colIndex1 < 0 || colIndex2 < 0 || colIndex1 >= colNum || colIndex2 >= colNum) {
      console.error("Move out of range");
      return;
    }
    const transactionSpecs = [];
    [table.formatLine[colIndex1], table.formatLine[colIndex2]] = [table.formatLine[colIndex2], table.formatLine[colIndex1]];
    transactionSpecs.push(setLineWithoutScroll(editor, table.fromLine + 1, TableEditor.rowCells2rowString(table.formatLine)));
    for (let i = 0; i < table.cells.length; i++) {
      const lineNumber = TableEditor.getLineNumber(table, i);
      [table.cells[i][colIndex1], table.cells[i][colIndex2]] = [table.cells[i][colIndex2], table.cells[i][colIndex1]];
      transactionSpecs.push(setLineWithoutScroll(editor, lineNumber, TableEditor.rowCells2rowString(table.cells[i])));
    }
    withoutScrollAndFocus(editorView, () => {
      editorView.dispatch(...transactionSpecs);
    });
  }
  async swapRows(table, rowIndex1, rowIndex2) {
    if (!table)
      return;
    const markdownView = this.plugin.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    const editor = markdownView == null ? void 0 : markdownView.editor;
    const editorView = editor == null ? void 0 : editor.cm;
    if (!editor || !editorView) {
      console.error("Cannot get editor");
      return;
    }
    const rowNum = table.cells.length;
    if (rowIndex1 < 1 || rowIndex2 < 1 || rowIndex1 >= rowNum || rowIndex2 >= rowNum) {
      console.error("Move out of range");
      return;
    }
    const transactionSpecs = [];
    [table.cells[rowIndex1], table.cells[rowIndex2]] = [table.cells[rowIndex2], table.cells[rowIndex1]];
    const lineNumber1 = TableEditor.getLineNumber(table, rowIndex1);
    const row1String = TableEditor.rowCells2rowString(table.cells[rowIndex1]);
    transactionSpecs.push(setLineWithoutScroll(editor, lineNumber1, row1String));
    const lineNumber2 = TableEditor.getLineNumber(table, rowIndex2);
    const row2String = TableEditor.rowCells2rowString(table.cells[rowIndex2]);
    transactionSpecs.push(setLineWithoutScroll(editor, lineNumber2, row2String));
    withoutScrollAndFocus(editorView, () => {
      editorView.dispatch(...transactionSpecs);
    });
  }
  async deleteRow(table, rowIndex) {
    if (!table)
      return;
    const markdownView = this.plugin.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    const editor = markdownView == null ? void 0 : markdownView.editor;
    const editorView = editor == null ? void 0 : editor.cm;
    if (!editor || !editorView) {
      console.error("Cannot get editor");
      return;
    }
    if (rowIndex == 0) {
      return;
    }
    const rowLineNumber = TableEditor.getLineNumber(table, rowIndex);
    withoutScrollAndFocus(editorView, () => {
      editorView.dispatch(deleteLine(editor, rowLineNumber));
    });
  }
  async deleteCol(table, colIndex) {
    if (!table)
      return;
    table.formatLine.splice(colIndex, 1);
    for (const row of table.cells)
      row.splice(colIndex, 1);
    const markdownView = this.plugin.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    const editor = markdownView == null ? void 0 : markdownView.editor;
    const editorView = editor == null ? void 0 : editor.cm;
    if (!editor || !editorView) {
      console.error("Cannot get editor");
      return;
    }
    if (table.formatLine.length == 1) {
      editorView.dispatch(deleteLines(editor, table.fromLine, table.toLine));
    } else {
      const transactionSpecs = [];
      transactionSpecs.push(setLineWithoutScroll(editor, table.fromLine + 1, TableEditor.rowCells2rowString(table.formatLine)));
      for (let i = 0; i < table.cells.length; i++) {
        const lineNumber = TableEditor.getLineNumber(table, i);
        transactionSpecs.push(setLineWithoutScroll(editor, lineNumber, TableEditor.rowCells2rowString(table.cells[i])));
      }
      withoutScrollAndFocus(editorView, () => {
        editorView.dispatch(...transactionSpecs);
      });
    }
  }
  static rowCells2rowString(cells) {
    const result = ["|"];
    try {
      for (const cell of cells) {
        result.push(cell.length == 0 ? "  " : cell);
        result.push("|");
      }
    } catch (err) {
      console.error(err);
      console.log(cells);
      throw err;
    }
    return result.join("");
  }
};

// src/ext.ts
var import_view = require("@codemirror/view");
var getTableEditorExt = (plugin) => import_view.ViewPlugin.fromClass(class {
  constructor() {
  }
  destroy() {
  }
  update(update) {
    if (plugin.isInReadingView())
      return;
    const dom = update.view.contentDOM;
    const tableEls = dom.querySelectorAll("table");
    tableEls.forEach((tableEl) => {
      if (tableEl.hasClass("intercepted"))
        return;
      tableEl.addClass("intercepted");
      const tablePos = update.view.posAtDOM(tableEl);
      const tableLine = update.state.doc.lineAt(tablePos).number - 1;
      for (let i = 0; i < tableEl.rows.length; i++) {
        const rowEl = tableEl.rows[i];
        for (let j = 0; j < rowEl.cells.length; j++) {
          const cellEl = rowEl.cells[j];
          const cellId = `cell_${tableLine}_${i}_${j}`;
          cellEl.id = cellId;
          cellEl.addEventListener("mouseenter", (e) => {
            var _a;
            cellEl.addClass(hoveredCellClassName);
            (_a = plugin.toolBar) == null ? void 0 : _a.tryShowFor(cellEl);
          });
          cellEl.addEventListener("mouseleave", (e) => {
            var _a;
            cellEl.removeClass(hoveredCellClassName);
            (_a = plugin.toolBar) == null ? void 0 : _a.tryHide(200);
          });
          cellEl.addEventListener("click", async (e) => {
            if (plugin.isInReadingView())
              return;
            if (e.targetNode != cellEl)
              return;
            e.preventDefault();
            e.stopPropagation();
            if (cellEl.getAttr("contenteditable") == "true")
              return;
            const editingCell = activeDocument.querySelector("." + editingCellClassName);
            if (editingCell instanceof HTMLTableCellElement && !cellEl.isSameNode(editingCell)) {
              await plugin.doneEdit(editingCell);
              setTimeout(() => {
                const newCellEl = activeDocument.getElementById(cellId);
                if (newCellEl instanceof HTMLTableCellElement) {
                  newCellEl.click();
                } else
                  console.error("cannot relocate");
              }, 200);
              return;
            }
            const table = plugin.tableEditor.getTable(tableLine);
            if (!table) {
              console.error("Cannot get table of cell ", cellEl);
              return;
            }
            const text = getCell(table, i, j);
            if (text == null)
              return;
            cellEl.focus();
            cellEl.addClass(editingCellClassName);
            cellEl.setAttr("contenteditable", true);
            if (text == "") {
              cellEl.innerText = " ";
              setCaretPosition(cellEl, 0);
            } else {
              cellEl.innerText = text;
              setCaretPosition(cellEl, text.length);
            }
          });
        }
      }
    });
  }
});

// src/menuItems.ts
var import_obsidian2 = require("obsidian");
var getInsertRowBelowItem = (plugin, cellEl) => (item) => {
  item.setTitle("Insert Row Below");
  item.onClick(async (e) => {
    const { tableLine, i, j } = parseCellId(cellEl.id);
    const table = plugin.tableEditor.getTable(tableLine);
    if (!table) {
      console.error("cannot locate table when trying to insert row below ", cellEl);
      return;
    }
    await plugin.tableEditor.insertRowBelow(table, i);
  });
};
var getInsertColRightItem = (plugin, cellEl) => (item) => {
  item.setTitle("Insert Column Right");
  item.onClick(async (e) => {
    const { tableLine, i, j } = parseCellId(cellEl.id);
    const table = plugin.tableEditor.getTable(tableLine);
    if (!table) {
      console.error("cannot locate table when trying to insert column below ", cellEl);
      return;
    }
    await plugin.tableEditor.insertColRight(table, i);
  });
};
var getCloneRowItem = (plugin, cellEl) => (item) => {
  item.setTitle("Clone Row");
  item.onClick(async (e) => {
    const { tableLine, i, j } = parseCellId(cellEl.id);
    const table = plugin.tableEditor.getTable(tableLine);
    if (!table) {
      console.error("cannot locate table when trying to copy row below ", cellEl);
      return;
    }
    await plugin.tableEditor.insertRowBelow(table, i, table.cells[i]);
  });
};
var getCloneColItem = (plugin, cellEl) => (item) => {
  item.setTitle("Clone Column");
  item.onClick(async (e) => {
    const { tableLine, i, j } = parseCellId(cellEl.id);
    const table = plugin.tableEditor.getTable(tableLine);
    if (!table) {
      console.error("cannot locate table when trying to copy row below ", cellEl);
      return;
    }
    const col = table.cells.map((row) => row[j]);
    console.log(col);
    await plugin.tableEditor.insertColRight(table, j, col);
  });
};
var getDelRowItem = (plugin, cellEl) => (item) => {
  item.setTitle("Delete Row");
  item.onClick(async (e) => {
    const { tableLine, i, j } = parseCellId(cellEl.id);
    const table = plugin.tableEditor.getTable(tableLine);
    if (!table) {
      console.error("cannot locate table when trying to copy row below ", cellEl);
      return;
    }
    await plugin.tableEditor.deleteRow(table, i);
  });
};
var getDelColItem = (plugin, cellEl) => (item) => {
  item.setTitle("Delete Column");
  item.onClick(async (e) => {
    const { tableLine, i, j } = parseCellId(cellEl.id);
    const table = plugin.tableEditor.getTable(tableLine);
    if (!table) {
      console.error("cannot locate table when trying to copy row below ", cellEl);
      return;
    }
    await plugin.tableEditor.deleteCol(table, j);
  });
};
var getMoveColRightItem = (plugin, cellEl) => (item) => {
  item.setTitle("Move Column Right");
  item.onClick(async (e) => {
    const { tableLine, i, j } = parseCellId(cellEl.id);
    const table = plugin.tableEditor.getTable(tableLine);
    if (!table) {
      console.error("cannot locate table when trying to copy row below ", cellEl);
      return;
    }
    const colNum = table.formatLine.length;
    if (j == colNum - 1) {
      new import_obsidian2.Notice("Current column is already the rightmost column.");
      return;
    }
    await plugin.tableEditor.swapCols(table, j, j + 1);
  });
};
var getMoveColLeftItem = (plugin, cellEl) => (item) => {
  item.setTitle("Move Column Left");
  item.onClick(async (e) => {
    const { tableLine, i, j } = parseCellId(cellEl.id);
    const table = plugin.tableEditor.getTable(tableLine);
    if (!table) {
      console.error("cannot locate table when trying to copy row below ", cellEl);
      return;
    }
    if (j == 0) {
      new import_obsidian2.Notice("Current column is already the leftmost column.");
      return;
    }
    await plugin.tableEditor.swapCols(table, j, j - 1);
  });
};
var getMoveRowDownItem = (plugin, cellEl) => (item) => {
  item.setTitle("Move Row Downward");
  item.onClick(async (e) => {
    const { tableLine, i, j } = parseCellId(cellEl.id);
    const table = plugin.tableEditor.getTable(tableLine);
    if (!table) {
      console.error("cannot locate table when trying to copy row below ", cellEl);
      return;
    }
    const rowNum = table.cells.length;
    if (i == rowNum - 1) {
      new import_obsidian2.Notice("Current column is already the bottom row.");
      return;
    }
    await plugin.tableEditor.swapRows(table, i, i + 1);
  });
};
var getMoveRowUpItem = (plugin, cellEl) => (item) => {
  item.setTitle("Move Row Upward");
  item.onClick(async (e) => {
    const { tableLine, i, j } = parseCellId(cellEl.id);
    const table = plugin.tableEditor.getTable(tableLine);
    if (!table) {
      console.error("cannot locate table when trying to copy row below ", cellEl);
      return;
    }
    if (i == 1) {
      new import_obsidian2.Notice("Current column is already the top row.");
      return;
    }
    await plugin.tableEditor.swapRows(table, i, i - 1);
  });
};
var getColAlignItem = (plugin, cellEl, aligned) => (item) => {
  item.setTitle("Set Column " + aligned.toUpperCase() + " Aligned");
  item.onClick(async (e) => {
    const { tableLine, i, j } = parseCellId(cellEl.id);
    const table = plugin.tableEditor.getTable(tableLine);
    if (!table) {
      console.error("cannot locate table when trying to copy row below ", cellEl);
      return;
    }
    await plugin.tableEditor.setColAligned(table, j, aligned);
  });
};

// src/icon.ts
var insertBelowIcon = `
<svg
	t="1661842034318"
	class="icon"
	viewBox="0 0 1024 1024"
	version="1.1"
	xmlns="http://www.w3.org/2000/svg"
	p-id="5688"
	width="16"
	height="16"
>
	<path
		d="M904 768H120c-4.4 0-8 3.6-8 8v80c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-80c0-4.4-3.6-8-8-8zM878.7 160H145.3c-18.4 0-33.3 14.3-33.3 32v464c0 17.7 14.9 32 33.3 32h733.3c18.4 0 33.3-14.3 33.3-32V192c0.1-17.7-14.8-32-33.2-32zM360 616H184V456h176v160z m0-224H184V232h176v160z m240 224H424V456h176v160z m0-224H424V232h176v160z m240 224H664V456h176v160z m0-224H664V232h176v160z" 
		p-id="5689"
		fill="currentColor"
	    stroke="currentColor"
	></path>
</svg>`;
var deleteIcon = `
<svg
	t="1661781161180"
	class="icon"
	viewBox="0 0 1024 1024"
	version="1.1"
	xmlns="http://www.w3.org/2000/svg"
	p-id="3242"
	width="16"
	height="16"
>
	<path
		d="M512 471.744l207.424-207.36a28.416 28.416 0 1 1 40.256 40.192L552.256 512l207.36 207.424a28.416 28.416 0 1 1-40.192 40.256L512 552.256l-207.424 207.36a28.416 28.416 0 1 1-40.256-40.192L471.744 512l-207.36-207.424a28.416 28.416 0 0 1 40.192-40.256L512 471.744z"
		p-id="3243"
		fill="currentColor"
	    stroke="currentColor"
	>
	</path>
</svg>`;
var insertRightIcon = `
<svg
	t="1661842059940"
	class="icon"
	viewBox="0 0 1024 1024"
	version="1.1"
	xmlns="http://www.w3.org/2000/svg"
	p-id="5924"
	width="16"
	height="16"
>
	<path
		d="M856 112h-80c-4.4 0-8 3.6-8 8v784c0 4.4 3.6 8 8 8h80c4.4 0 8-3.6 8-8V120c0-4.4-3.6-8-8-8zM656 112H192c-17.7 0-32 14.9-32 33.3v733.3c0 18.4 14.3 33.3 32 33.3h464c17.7 0 32-14.9 32-33.3V145.3c0-18.4-14.3-33.3-32-33.3zM392 840H232V664h160v176z m0-240H232V424h160v176z m0-240H232V184h160v176z m224 480H456V664h160v176z m0-240H456V424h160v176z m0-240H456V184h160v176z" 
		p-id="5925"
		fill="currentColor"
	    stroke="currentColor"
	></path>
</svg>`;
var moveRightIcon = `
<svg
	t="1662187765148"
	class="icon"
	viewBox="0 0 1024 1024"
	version="1.1"
	xmlns="http://www.w3.org/2000/svg"
	p-id="9678"
	width="16"
	height="16"
>
	<path
		d="M593.450667 512.128L360.064 278.613333l45.290667-45.226666 278.613333 278.762666L405.333333 790.613333l-45.226666-45.269333z" 
		p-id="9679"
		fill="currentColor"
    	stroke="currentColor"
	></path>
</svg>`;
var moveLeftIcon = `
<svg
	t="1662188090144"
	class="icon"
	viewBox="0 0 1024 1024"
	version="1.1"
	xmlns="http://www.w3.org/2000/svg"
	p-id="6067"
	width="16"
	height="16"
>
	<path
		d="M641.28 278.613333l-45.226667-45.226666-278.634666 278.762666 278.613333 278.485334 45.248-45.269334-233.365333-233.237333z"
		p-id="6068"
		fill="currentColor"
    	stroke="currentColor"
	></path>
</svg>`;
var cloneIcon = `
<svg t="1671932954709" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4984" width="16" height="16"><path d="M160 160v544h128v-64H224V224h416v64h64V160H160z m160 160v544h544V320H320z m64 64h416v416H384V384z" fill="currentColor"
    	stroke="currentColor" p-id="4985"></path></svg>`;
var upwardIcon = `
<svg t="1671934713104" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2640" width="16" height="16"><path d="M830.24 685.76l11.328-11.312a16 16 0 0 0 0-22.64L530.448 340.688a16 16 0 0 0-22.64 0L196.688 651.808a16 16 0 0 0 0 22.64l11.312 11.312a16 16 0 0 0 22.624 0l288.496-288.512L807.632 685.76a16 16 0 0 0 22.624 0z" fill="currentColor"
	   stroke="currentColor" p-id="2641"></path></svg>`;
var downIcon = `
<svg t="1671934792670" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3163" width="16" height="16"><path d="M830.24 340.688l11.328 11.312a16 16 0 0 1 0 22.624L530.448 685.76a16 16 0 0 1-22.64 0L196.688 374.624a16 16 0 0 1 0-22.624l11.312-11.312a16 16 0 0 1 22.624 0l288.496 288.496 288.512-288.496a16 16 0 0 1 22.624 0z" fill="currentColor"
	   stroke="currentColor" p-id="3164"></path></svg>`;

// src/toolBar.ts
var import_obsidian3 = require("obsidian");
var ToolBar = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.rowOpBarEl = createDiv({ cls: "ob-table-enhancer-row-bar" });
    this.colOpBarEl = createDiv({ cls: "ob-table-enhancer-col-bar" });
    this.rowOpBarEl.createDiv({
      cls: "ob-table-enhancer-row-bar-button"
    }, (el) => {
      el.innerHTML = upwardIcon;
      el.onclick = async () => {
        if (this.cell.i == 1) {
          new import_obsidian3.Notice("Current column is already the top row.");
          return;
        }
        const table = await plugin.tableEditor.getTable(this.cell.tableLine);
        if (!table) {
          console.error("Cannot get table.");
          return;
        }
        await this.plugin.tableEditor.swapRows(table, this.cell.i, this.cell.i - 1);
      };
    });
    this.rowOpBarEl.createDiv({
      cls: "ob-table-enhancer-row-bar-button"
    }, (el) => {
      el.innerHTML = downIcon;
      el.onclick = async () => {
        const table = await plugin.tableEditor.getTable(this.cell.tableLine);
        if (!table) {
          console.error("Cannot get table.");
          return;
        }
        const rowNum = table.cells.length;
        if (this.cell.i == rowNum - 1) {
          new import_obsidian3.Notice("Current column is already the bottom row.");
          return;
        }
        await this.plugin.tableEditor.swapRows(table, this.cell.i, this.cell.i + 1);
      };
    });
    this.rowOpBarEl.createDiv({
      cls: "ob-table-enhancer-row-bar-button"
    }, (el) => {
      el.innerHTML = insertBelowIcon;
      el.onclick = async () => {
        const table = await plugin.tableEditor.getTable(this.cell.tableLine);
        if (!table) {
          console.error("Cannot get table.");
          return;
        }
        await this.plugin.tableEditor.insertRowBelow(table, this.cell.i);
      };
    });
    this.colOpBarEl.createDiv({
      cls: "ob-table-enhancer-col-bar-button"
    }, (el) => {
      el.innerHTML = moveLeftIcon;
      el.onclick = async () => {
        if (this.cell.j == 0) {
          new import_obsidian3.Notice("Current column is already the leftmost column.");
          return;
        }
        const table = await plugin.tableEditor.getTable(this.cell.tableLine);
        if (!table) {
          console.error("Cannot get table.");
          return;
        }
        await plugin.tableEditor.swapCols(table, this.cell.j, this.cell.j - 1);
      };
    });
    this.colOpBarEl.createDiv({
      cls: "ob-table-enhancer-col-bar-button"
    }, (el) => {
      el.innerHTML = insertRightIcon;
      el.onclick = async () => {
        const table = await plugin.tableEditor.getTable(this.cell.tableLine);
        if (!table) {
          console.error("Cannot get table.");
          return;
        }
        await this.plugin.tableEditor.insertColRight(table, this.cell.j);
      };
    });
    this.rowOpBarEl.createDiv({
      cls: "ob-table-enhancer-row-bar-button"
    }, (el) => {
      el.innerHTML = deleteIcon;
      el.onclick = async () => {
        if (this.cell.i == 0) {
          new import_obsidian3.Notice("You can't delete the header of a table.");
          return;
        }
        const table = await plugin.tableEditor.getTable(this.cell.tableLine);
        if (!table) {
          console.error("Cannot get table.");
          return;
        }
        await this.plugin.tableEditor.deleteRow(table, this.cell.i);
      };
    });
    this.colOpBarEl.createDiv({
      cls: "ob-table-enhancer-col-bar-button"
    }, (el) => {
      el.innerHTML = deleteIcon;
      el.onclick = async () => {
        const table = await plugin.tableEditor.getTable(this.cell.tableLine);
        if (!table) {
          console.error("Cannot get table.");
          return;
        }
        await this.plugin.tableEditor.deleteCol(table, this.cell.j);
      };
    });
    this.colOpBarEl.createDiv({
      cls: "ob-table-enhancer-col-bar-button"
    }, (el) => {
      el.innerHTML = moveRightIcon;
      el.onclick = async () => {
        const table = await plugin.tableEditor.getTable(this.cell.tableLine);
        if (!table) {
          console.error("Cannot get table.");
          return;
        }
        const colNum = table.formatLine.length;
        if (this.cell.j == colNum - 1) {
          new import_obsidian3.Notice("Current column is already the rightmost column.");
          return;
        }
        await this.plugin.tableEditor.swapCols(table, this.cell.j, this.cell.j + 1);
      };
    });
    this.colOpBarEl.createDiv({
      cls: "ob-table-enhancer-col-bar-button"
    }, (el) => {
      el.innerHTML = cloneIcon;
      el.onclick = async () => {
        const table = await plugin.tableEditor.getTable(this.cell.tableLine);
        if (!table) {
          console.error("Cannot get table.");
          return;
        }
        const col = table.cells.map((row) => row[this.cell.j]);
        await this.plugin.tableEditor.insertColRight(table, this.cell.j, col);
      };
    });
    this.rowOpBarEl.createDiv({
      cls: "ob-table-enhancer-row-bar-button"
    }, (el) => {
      el.innerHTML = cloneIcon;
      el.onclick = async () => {
        const table = await plugin.tableEditor.getTable(this.cell.tableLine);
        if (!table) {
          console.error("Cannot get table.");
          return;
        }
        await this.plugin.tableEditor.insertRowBelow(table, this.cell.i, table.cells[this.cell.i]);
      };
    });
    plugin.registerDomEvent(activeDocument, "scroll", (e) => {
      this.colOpBarEl.style.opacity = "0";
      this.rowOpBarEl.style.opacity = "0";
      this.activeOpBars = [];
    }, true);
    if (activeDocument) {
      activeDocument.body.appendChild(this.rowOpBarEl);
      activeDocument.body.appendChild(this.colOpBarEl);
    }
  }
  tryShowFor(cellEl) {
    if (this.plugin.isInReadingView())
      return;
    if (this.hideTimeout)
      clearTimeout(this.hideTimeout);
    this.cell = parseCellId(cellEl.id);
    if (this.cell.j == 0) {
      this.activeOpBars.push(this.rowOpBarEl);
      this.rowOpBarEl.style.opacity = "1";
      const cellRect = cellEl.getBoundingClientRect();
      const toolBarRect = this.rowOpBarEl.getBoundingClientRect();
      this.rowOpBarEl.style.top = `${cellRect.top}px`;
      this.rowOpBarEl.style.left = `${cellRect.left - toolBarRect.width}px`;
      this.rowOpBarEl.style.height = `${cellRect.height}px`;
    }
    if (this.cell.i == 0) {
      this.activeOpBars.push(this.colOpBarEl);
      this.colOpBarEl.style.opacity = "1";
      const cellRect = cellEl.getBoundingClientRect();
      const toolBarRect = this.colOpBarEl.getBoundingClientRect();
      this.colOpBarEl.style.top = `${cellRect.top - toolBarRect.height}px`;
      this.colOpBarEl.style.left = `${cellRect.left}px`;
      this.colOpBarEl.style.width = `${cellRect.width}px`;
    }
  }
  tryHide(timeout) {
    this.hideTimeout = setTimeout(() => {
      this.colOpBarEl.style.opacity = "0";
      this.rowOpBarEl.style.opacity = "0";
      this.activeOpBars = [];
    }, timeout);
    const stopHideTimeout = (e) => {
      clearTimeout(this.hideTimeout);
      this.activeOpBars.forEach((toolBarEl) => {
        toolBarEl.onmouseout = (e2) => {
          if (e2.relatedTarget instanceof Node && toolBarEl.contains(e2.relatedTarget))
            return;
          this.tryHide(500);
        };
      });
    };
    this.activeOpBars.forEach((toolbar) => {
      toolbar.onmouseenter = stopHideTimeout;
    });
  }
  onUnload() {
    this.colOpBarEl.remove();
    this.rowOpBarEl.remove();
  }
};

// main.ts
var TableEnhancer2 = class extends import_obsidian4.Plugin {
  async onload() {
    this.tableEditor = new TableEditor(this);
    this.toolBar = new ToolBar(this);
    const tableEditorExt = getTableEditorExt(this);
    this.registerEditorExtension(tableEditorExt);
    this.app.workspace.onLayoutReady(() => {
      this.registerDomEvent(activeDocument, "keydown", async (e) => {
        const cellEl = activeDocument.querySelector("." + editingCellClassName);
        if (!(cellEl instanceof HTMLTableCellElement))
          return;
        if (!e.repeat && e.key == "Enter" && e.shiftKey) {
          e.preventDefault();
          const prevCaretPos = getCaretPosition(cellEl);
          const text1 = cellEl.innerText.slice(0, prevCaretPos);
          const text2 = cellEl.innerText.slice(prevCaretPos + 1);
          cellEl.innerText = [text1, " <br> ", text2].join("");
          setCaretPosition(cellEl, prevCaretPos + 6);
          return;
        }
        if (!e.repeat && (e.key == "Enter" || e.key == "Escape")) {
          e.preventDefault();
          await this.doneEdit(cellEl);
          return;
        }
        if (e.key == "ArrowLeft") {
          e.preventDefault();
          e.stopPropagation();
          const caretPos = getCaretPosition(cellEl);
          const { tableLine, i, j } = parseCellId(cellEl.id);
          if (caretPos == 0) {
            setTimeout(() => {
              const newCellEl = activeDocument.getElementById(`cell_${tableLine}_${i}_${j - 1}`);
              if (newCellEl instanceof HTMLTableCellElement) {
                newCellEl.click();
              }
            }, 200);
          } else {
            setCaretPosition(cellEl, caretPos - 1);
          }
          return;
        }
        if (e.key == "ArrowRight") {
          e.preventDefault();
          e.stopPropagation();
          const caretPos = getCaretPosition(cellEl);
          const { tableLine, i, j } = parseCellId(cellEl.id);
          if (caretPos >= cellEl.innerText.length) {
            setTimeout(() => {
              const newCellEl = activeDocument.getElementById(`cell_${tableLine}_${i}_${j + 1}`);
              if (newCellEl instanceof HTMLTableCellElement) {
                newCellEl.click();
              }
            }, 200);
          } else {
            setCaretPosition(cellEl, caretPos + 1);
          }
          return;
        }
        if (!e.repeat && e.ctrlKey && e.key == "a") {
          e.preventDefault();
          e.stopPropagation();
          const selection = activeWindow.getSelection();
          const range = activeDocument.createRange();
          range.selectNodeContents(cellEl);
          selection == null ? void 0 : selection.removeAllRanges();
          selection == null ? void 0 : selection.addRange(range);
          return;
        }
        if (e.key == "ArrowUp") {
          e.preventDefault();
          e.stopPropagation();
          const { tableLine, i, j } = parseCellId(cellEl.id);
          setTimeout(() => {
            const newCellEl = activeDocument.getElementById(`cell_${tableLine}_${i - 1}_${j}`);
            if (newCellEl instanceof HTMLTableCellElement) {
              newCellEl.click();
            }
          }, 200);
          return;
        }
        if (e.key == "ArrowDown") {
          e.preventDefault();
          e.stopPropagation();
          const { tableLine, i, j } = parseCellId(cellEl.id);
          setTimeout(() => {
            const newCellEl = activeDocument.getElementById(`cell_${tableLine}_${i + 1}_${j}`);
            if (newCellEl instanceof HTMLTableCellElement) {
              newCellEl.click();
            }
          }, 200);
          return;
        }
        if (e.shiftKey && e.key == "Tab") {
          e.preventDefault();
          e.stopPropagation();
          const { tableLine, i, j } = parseCellId(cellEl.id);
          const table = this.tableEditor.getTable(tableLine);
          if (!table) {
            console.error("Cannot get table when trying to done edit");
            return;
          }
          const rowNum = table.cells.length;
          const colNum = table.formatLine.length;
          let nextCell;
          if (i == 0 && j == 0) {
            nextCell = activeDocument.getElementById(`cell_${tableLine}_${rowNum - 1}_${colNum - 1}`);
          } else if (j == 0) {
            nextCell = activeDocument.getElementById(`cell_${tableLine}_${i - 1}_${colNum - 1}`);
          } else {
            nextCell = activeDocument.getElementById(`cell_${tableLine}_${i}_${j - 1}`);
          }
          if (nextCell instanceof HTMLTableCellElement)
            nextCell.click();
          return;
        }
        if (e.key == "Tab") {
          e.preventDefault();
          e.stopPropagation();
          const { tableLine, i, j } = parseCellId(cellEl.id);
          const table = this.tableEditor.getTable(tableLine);
          if (!table) {
            console.error("Cannot get table when trying to done edit");
            return;
          }
          const rowNum = table.cells.length;
          const colNum = table.formatLine.length;
          let nextCell;
          if (i == rowNum - 1 && j == rowNum - 1) {
            nextCell = activeDocument.getElementById(`cell_${tableLine}_0_0`);
          } else if (j == colNum - 1) {
            nextCell = activeDocument.getElementById(`cell_${tableLine}_${i + 1}_0`);
          } else {
            nextCell = activeDocument.getElementById(`cell_${tableLine}_${i}_${j + 1}`);
          }
          if (nextCell instanceof HTMLTableCellElement)
            nextCell.click();
          return;
        }
      });
    });
    this.registerEvent(this.app.workspace.on("editor-menu", (menu, view) => {
      const hoveredCell = activeDocument.querySelector("." + hoveredCellClassName);
      if (!(hoveredCell instanceof HTMLTableCellElement))
        return;
      menu.addItem(getInsertRowBelowItem(this, hoveredCell));
      menu.addItem(getInsertColRightItem(this, hoveredCell));
      menu.addItem(getCloneRowItem(this, hoveredCell));
      menu.addItem(getCloneColItem(this, hoveredCell));
      menu.addItem(getDelRowItem(this, hoveredCell));
      menu.addItem(getDelColItem(this, hoveredCell));
      menu.addItem(getMoveColLeftItem(this, hoveredCell));
      menu.addItem(getMoveColRightItem(this, hoveredCell));
      menu.addItem(getMoveRowUpItem(this, hoveredCell));
      menu.addItem(getMoveRowDownItem(this, hoveredCell));
      menu.addItem(getColAlignItem(this, hoveredCell, "left"));
      menu.addItem(getColAlignItem(this, hoveredCell, "right"));
      menu.addItem(getColAlignItem(this, hoveredCell, "center"));
    }));
  }
  async doneEdit(cellEl) {
    if (!cellEl) {
      const el = activeDocument.querySelector("." + editingCellClassName);
      if (el instanceof HTMLTableCellElement)
        cellEl = el;
      else
        return;
    }
    cellEl.setAttr("contenteditable", false);
    cellEl.removeClass(editingCellClassName);
    const { tableLine, i, j } = parseCellId(cellEl.id);
    const table = this.tableEditor.getTable(tableLine);
    if (!table) {
      console.error("Cannot get table when trying to done edit");
      return;
    }
    await this.tableEditor.updateCell(table, i, j, cellEl.innerText.trim());
  }
  isInReadingView() {
    const markdownView = this.app.workspace.getActiveViewOfType(import_obsidian4.MarkdownView);
    return markdownView instanceof import_obsidian4.MarkdownView && markdownView.getMode() == "preview";
  }
  onunload() {
  }
};
